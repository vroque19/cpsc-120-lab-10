# Address Book

Let's take something very complex and overly simplify it. Or another way to think about this is to create an abstract model of something complex, focusing only on the details that we think are important.

People are really complicated. They have all sorts of features that make each and every human being very unique. When we try to keep the people in our lives organized, we may turn to an addressbook which creates an abstraction of who people are by reducing down their complexity to pieces of information such as their name, address, phone number etc.

This is a good starting point for us to begin to learn how to use classes to define our own types. We'll us C++ capacity to create new types to create a Person class which will represent people as just a name and a phone number.

There are four source files in this project. Since this is our first experience defining a class, study how the class is defined in `person.h`. No changes are necessary to `person.h` to complete this project. Focus your attention on `addressbook.cc` and `person.c` to complete the project.

* `addressbook.cc` This file defines the `main()` function. It uses the `person` class defined in the other files to create an addressbook application.
* `person.cc` The implementation of the person class.
* `person.h` The definition of the person class. _Do not edit this file._
* `person_unittest.cc` The person class unit test. _Do not edit this file._

To help us verify that our class implements all the features we need, we have unit tests defined in `person_unittest.cc`. Although you do not need to make any changes in this file, running the tests (via `make unittest`) will ensure that your implementation of the class meets the specifications.

The Person class is defined in two files `person.h` and `person.cc`. The `.h` is called a header file and provides a public definition of what a Person class is. In other words, the definition is the outside of the class and it is what you the programmer can see and use when programming in your application (your `main()` function). The implementation is defined in `person.cc` and it is the inside-parts of what makes up a Person. You can only see and use the insides of the class from within `person.cc`.

As the programmer, your role is to first create the inside-parts of the Person class in `person.cc`, verify that it works using the unit tests, and then use the Person class in the main function in `addressbook.cc`. This is a little tricky and sophisticated and it is our first step in doing much more sophisticated programs.

And what is the difference between a [class](https://en.wikipedia.org/wiki/Class_(computer_programming)) and an [object](https://en.wikipedia.org/wiki/Object_(computer_science)#Object-oriented_programming)? C++ is an [object-oriented programming language](https://en.wikipedia.org/wiki/Object-oriented_programming) which means that we can create abstractions or models of things using the keyword `class`. Our models hold data (member variables) and behaviors (member functions). The data and the behavior enables us to model concrete things as a class. Many times people will interchangeably use the words object and class to mean the samething. A good way to distinguish between the two is to think of the class as an abstract description of something like the idea of dogs, cats, or colors and objects are instances of concrete examples of dogs, cats, or colors. For example, you may have a pet that is a dog (a kind of abstract thing, a class) and your dog's name is Spot (a concrete instance of a kind of thing, an object).

In our exercise, we're taking people and modeling them as a name and phone number (a Person class) so we can write an addressbook application that uses three objects which are entered by the computer user. And since they are concrete objects, we can sort them alphabetically since they are not abstract ideas of people. 

We've only used the [C++ vector](https://en.cppreference.com/w/cpp/container/vector) to work with our command line arguments and in this exercise we will use a C++ vector to organize our Person objects.

In the example below, we create a C++ vector that can hold onto Person objects. It demonstrates two different ways to create a Person object. Each time, the variable my_friend has it's value *copied* into the C++ vector using the member function [`push_back()`](https://en.cppreference.com/w/cpp/container/vector/push_back). It is important to remember that the value is *copied* and not _moved_. In the final line, the `addressbook` is sorted using [`sort()`](https://en.cppreference.com/w/cpp/algorithm/sort). The algorithm `sort()` starts at the `addressbook`'s  beginning and continues to the `addressbook`'s end and uses a very fast algorithm to sort the items in place. This means that after the function `sort()` completes all the elements in `addressbook` are in ascending order (smallest item first, biggest item last).

```c++
vector<Person> addressbook;
Person my_friend("Klaus Kinski", "504-555-1212");
addressbook.push_back(my_friend);
my_friend = Person("Werner Herzog", "407-555-1212");
addressbook.push_back(my_friend);
sort(addressbook.begin(), addressbook.end());
```

To verify that our `addressbook` was sorted, we will print the items in the addressbook to the terminal. We already know how to use a for loop, while loop, and do-while loop along with the `at()` member function to print out elements from a C++ vector. In this exercise, let's do it in a different way which is very concise and elegant. In C++11 and later, there is a range-based for loop which does away with the need to count through a container like a vector.

For example, we know how to use a for loop to get at each element in a vector using the following pattern.

```c++
vector<string> args = vector<string>(argv, argv + argc);
for(int i = 0; i < args.size(); i++) {
	try {
		cout << args.at(i) << "\n";
	} catch(exception const& problem) {
		cout << "There was a problem!\n";
		cout << problem.what() << "\n";
		exit(1);
	}
}
```

Using a range-based for loop and taking advantage of [auto (C++11's placeholder type specifiers)](https://en.cppreference.com/w/cpp/language/auto), we can take the same idea and write it more concisely as the following example.

```c++
auto args = vector<string>(argv, argv + argc);
for(const auto& item : args){
	cout << item << "\n";
}
```


## Requirements

Using `getline()` and `cout`, prompt the computer user to input 3 different names and phone numbers. Use getline to read the person's whole name into a string variable. Next, read in the computer user's phone number using the same mechanism.

Create a total of three person objects and store each object into a vector. Use the `push_back()` member function to insert the person object into the vector object. Since the Person object is copied into the vector, you do not need to make three separate Person variables. You can achieve your goal with only one variable.

Once the Person objects have been added to the vector, use the [`sort()`](https://en.cppreference.com/w/cpp/algorithm/sort) function from the C++ algorithm library to sort the vector. Since we are sorting Person objects, the boolean operators `<`, `>`, `==`, and `!=` need to be defined for the Person class. The `sort()` function is smart enough to use the `<` and `>` operators to sort the vector.

Use a range-based for loop to print the sorted vector to the terminal.

The starting code defines a series of `TODO` comments which you can use to formulate your plan and develop your program.

Write your program progressively. Compile your program often and check that you're making progress. Make sure your program behaves the way you expect.

The output of your program must match the output given in the section Example Output below.

To compile your program, you use the `make` command. A Makefile is provided for this exercise.

The Makefile has the following targets:

* all: builds the project
* clean: removes object and dependency files
* spotless: removes everything the clean target removes and all binaries
* format: outputs a [`diff`](https://en.wikipedia.org/wiki/Diff) showing where your formatting differes from the [Google C++ style guide](https://google.github.io/styleguide/cppguide.html)
* lint: output of the [linter](https://en.wikipedia.org/wiki/Lint_(software)) to give you tips on how to improve your code
* header: check to make sure your files have the appropriate header
* test: run tests to help you verify your program is meeting the assignment's requirements. This does not grade your assignment.
* unittest: run unit tests to verify parts of your program performs according to the instructor supplied unit tests.

## Don't Forget

Please remember that:

- You need to put a header in every file.
- You need to follow the [Google C++ Style Guide](https://google.github.io/styleguide/cppguide.html).
- Remove the `TODO` comments.

## Testing Your Code

Computers only ever do exactly what they are told, exactly the way they are told it, and never anything else. Testing is an important process to writing a program. You need to test for the program to behave correctly and test that the program behaves incorrectly in a predictable way.

As programmers we have to remember that there are a lot of ways that we can write the wrong program and only one to a few ways to write the correct program. We have to be aware of [cognitive biases](https://en.wikipedia.org/wiki/List_of_cognitive_biases) that we may exercise that lead us to believe we have correctly completed our program. That belief may be incorrect and our software may have errors. [Errors in software](https://www.wired.com/2005/11/historys-worst-software-bugs/) may lead to loss of [life](https://www.nytimes.com/2019/03/14/business/boeing-737-software-update.html), [property](https://en.wikipedia.org/wiki/Mariner_1), [reputation](https://en.wikipedia.org/wiki/Pentium_FDIV_bug), or [all of the above](https://en.wikipedia.org/wiki/2009%E2%80%9311_Toyota_vehicle_recalls).

### Test strategy

Start simple, and work your way up. Good tests are specific, cover a broad range of fundamentally different possibilities, can identify issues quickly, easily, and directly, without need for much set up, and can almost be diagnosed by inspection if the code fails to execute the test correctly.

## Example Output

Please ensure your program's output is identical to the example below.

```
$ make unittest
set -e; clang++ -MM -g -O3 -Wall -pipe -std=c++14 -D LINUX -D AMD64 person.cc \
| sed 's/\(person\)\.o[ :]*/\1.o person.d : /g' > person.d; \
[ -s person.d ] || rm -f person.d
set -e; clang++ -MM -g -O3 -Wall -pipe -std=c++14 -D LINUX -D AMD64 addressbook.cc \
| sed 's/\(addressbook\)\.o[ :]*/\1.o addressbook.d : /g' > addressbook.d; \
[ -s addressbook.d ] || rm -f addressbook.d
rm: cannot remove 'unittest': No such file or directory
make: [Makefile:134: cleanunittest] Error 1 (ignored)
clang++ -g -O3 -Wall -pipe -std=c++14 -D LINUX -D AMD64 -c person.cc
Running main() from /build/googletest-j5yxiC/googletest-1.10.0/googletest/src/gtest_main.cc
[==========] Running 8 tests from 1 test suite.
[----------] Global test environment set-up.
[----------] 8 tests from PersonTest
[ RUN      ] PersonTest.GetName
[       OK ] PersonTest.GetName (0 ms)
[ RUN      ] PersonTest.GetPhoneNumber
[       OK ] PersonTest.GetPhoneNumber (0 ms)
[ RUN      ] PersonTest.SetPhoneNumber
[       OK ] PersonTest.SetPhoneNumber (0 ms)
[ RUN      ] PersonTest.Write
[       OK ] PersonTest.Write (0 ms)
[ RUN      ] PersonTest.OperatorEqualTo
[       OK ] PersonTest.OperatorEqualTo (0 ms)
[ RUN      ] PersonTest.OperatorNotEqualTo
[       OK ] PersonTest.OperatorNotEqualTo (0 ms)
[ RUN      ] PersonTest.OperatorLessThan
[       OK ] PersonTest.OperatorLessThan (0 ms)
[ RUN      ] PersonTest.OperatorGreaterThan
[       OK ] PersonTest.OperatorGreaterThan (0 ms)
[----------] 8 tests from PersonTest (0 ms total)

[----------] Global test environment tear-down
[==========] 8 tests from 1 test suite ran. (0 ms total)
[  PASSED  ] 8 tests.
$ make
clang++ -g -O3 -Wall -pipe -std=c++14 -D LINUX -D AMD64 -c addressbook.cc
clang++ -g -O3 -Wall -pipe -std=c++14 -o addressbook addressbook.o person.o 
$ ./addressbook
Let's add 3 to your address book!
Please enter a full name: Zeppo Marx
Please enter a phone number: 212-555-1212
Please enter a full name: Harpo Marx
Please enter a phone number: 213-555-1212
Please enter a full name: Groucho Marx
Please enter a phone number: 415-555-1212
Let's sort your addressbook!
Great! Let's print out all the enteries in your addressbook.
Groucho Marx 415-555-1212
Harpo Marx 213-555-1212
Zeppo Marx 212-555-1212
```

